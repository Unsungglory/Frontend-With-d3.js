<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="initial-scale = 1, user-scalable = no" />

    <link href="./engine/css/normalize.css" rel="stylesheet" type="text/css" />
    <link href="./engine/css/master.css" rel="stylesheet" type="text/css">

    <!-- websiteInfo -->
    <script src="./websiteInfo.js" type="text/javascript"></script>

    <!-- ADD FUND TILES -->
    <script>
        const addFundTiles = true;
    </script>

    <!-- Add Scripts -->
    <script defer src="./engine/js/init.js"></script>

    <!-- ADD SMA FUNCTIONALITY -->
    <link href="./SMA/css/sma.css" rel="stylesheet" type="text/css" />
    <script src="./SMA/sma.js" type="text/javascript"></script>

    <style>
        .title-wrapper-2 {
            display: grid;
            grid-template-columns: 50% 44%;
            column-gap: 5%;
        }

        .dot-1 {
            background-color: rgba(0, 95, 158, 1);
        }

        .dot-2 {
            background-color: #B42573;
        }

        .dot-3 {
            background-color: #E3E3E3;
            border-radius: 0;
        }

        .domain {
            display: none;
        }

        .toggle-wrapper path {
            transition: .5s fill ease-in-out;
        }

        .toggle-wrapper {
            position: relative;
            left: -6%;
        }

        .axis {
            color: rgba(0, 0, 0, 0.5)
        }

        .x-axis .domain {
            display: block;
            opacity: .5;
        }


        .x-axis .tick:first-of-type {
            text-anchor: start;
        }

        .x-axis .tick {
            text-anchor: middle;
        }

        .x-axis .tick:last-of-type {
            text-anchor: end;
        }

        @media (max-width: 1700px) {
            @media (max-height: 770px) {}
        }

        @media (max-width: 1200px) {}
    </style>
</head>

<body>

    <!-- page content -->
    <div id="master-float">

        <div id="master-container">
            <!-- navigation -->
            <div id="nav-container"></div>
            <!-- end navigation -->

            <section id="content-size-setter">
                <section id="content-padding">
                    <section id='content-area'>

                        <!-- content title -->
                        <div class="title-wrapper-2">
                            <div>
                                <h1 style="width:33ch;">
                                    Venture capital is funding innovation outside of the U.S.
                                </h1>
                                <h2>
                                    This year might be the turning point for international stocks
                                </h2>
                            </div>

                            <div class='blurb'>
                                America is likely to remain a primary engine for innovation, but it would be
                                shortsighted to think of the U.S. as the sole province of inventive companies.
                            </div>
                        </div>
                        <!-- end content title -->

                        <div id='main-page-content'>
                            <!-- chart title & legend area -->
                            <section class="chart-ui-row">
                            </section>


                            <section class="chart-ui-row">
                                <div class="chart-title-wrapper">
                                    <h3>Global venture capital funding (%)</h3>

                                    <div class="legend-wrapper" style="margin-top: 3%;">
                                        <div class="legend-item">
                                            <div class="legend-dot dot-1" style='background-color: #005F9D;'></div>
                                            <span class='p-16'>U.S.</span>
                                        </div>
                                        <div class="legend-item">
                                            <div class="legend-dot dot-2"></div>
                                            <span class='p-16'>Outside the U.S.</span>
                                        </div>
                                    </div>

                                </div>

                            </section>
                            <!-- end chart title & legend area -->

                            <!-- chart -->
                            <section class="chart-wrapper-a">
                                <div id="chart"></div>
                            </section>
                            <!-- end chart -->

                            <!-- disclosure content -->
                            <div id="disclosure-wrapper">
                                <p>
                                    Source: Pitchbook. Data through 12/31/21.
                                </p>
                                <p>
                                    <span>
                                        Investors should carefully consider investment objectives, risks, charges and
                                        expenses. This and other important information is contained in the fund
                                        prospectuses and summary prospectuses, which can be obtained from a financial
                                        professional and should be read carefully before investing.
                                    </span>
                                </p>
                                <p>
                                    Statements attributed to an individual represent the opinions of that individual as
                                    of the date published and do not necessarily reflect the opinions of Capital Group
                                    or its affiliates. This information is intended to highlight issues and should not
                                    be considered advice, an endorsement or a recommendation.
                                </p>
                                <p>
                                    This content, developed by Capital Group, home of American Funds, should not be used
                                    as a primary basis for investment decisions and is not intended to serve as
                                    impartial investment or fiduciary advice.
                                </p>
                                <p>
                                    All Capital Group trademarks mentioned are owned by The Capital Group Companies,
                                    Inc., an affiliated company or fund. All other company and product names mentioned
                                    are the property of their respective companies.
                                </p>
                                <p>
                                    American Funds Distributors, Inc., member FINRA.
                                </p>
                                <p>
                                    Â© 2022 Capital Group. All rights reserved.
                                </p>
                            </div>
                            <!-- end disclosure content -->
                        </div>
                    </section>

                </section>
            </section>
        </div>
    </div>
    <!-- end page content -->
</body>

<script src="./engine/js/d3.min.js"></script>

<script>
    const data = [
        { date: "Jan 1 2022 17:00:00 GMT-0700 (Pacific Daylight Time)", val1: 51.2860298608561, val2: 48.713970139143896, },
        { date: "Jan 1 2021 17:00:00 GMT-0700 (Pacific Daylight Time)", val1: 49.05778745486366, val2: 50.94221254513634, },
        { date: "Jan 1 2020 17:00:00 GMT-0700 (Pacific Daylight Time)", val1: 47.9331973770695, val2: 52.066802622930496, },
        { date: "Jan 1 2019 17:00:00 GMT-0700 (Pacific Daylight Time)", val1: 46.036010805895046, val2: 53.963989194104954, },
        { date: "Jan 1 2018 17:00:00 GMT-0700 (Pacific Daylight Time)", val1: 42.500596137717515, val2: 57.499403862282485, },
        { date: "Jan 1 2017 17:00:00 GMT-0700 (Pacific Daylight Time)", val1: 43.65654631946241, val2: 56.34345368053758, },
        { date: "Jan 1 2016 17:00:00 GMT-0700 (Pacific Daylight Time)", val1: 44.06060626474454, val2: 55.93939373525546, },
        { date: "Jan 1 2015 17:00:00 GMT-0700 (Pacific Daylight Time)", val1: 48.67776601560011, val2: 51.3222339843999, },
        { date: "Jan 1 2014 17:00:00 GMT-0700 (Pacific Daylight Time)", val1: 45.41555377298569, val2: 54.58444622701432, },
        { date: "Jan 1 2013 17:00:00 GMT-0700 (Pacific Daylight Time)", val1: 65.10838108342793, val2: 34.89161891657207, },
        { date: "Jan 1 2012 17:00:00 GMT-0700 (Pacific Daylight Time)", val1: 65.46958727695677, val2: 34.530412723043206, },
        { date: "Jan 1 2011 17:00:00 GMT-0700 (Pacific Daylight Time)", val1: 66.62714324218443, val2: 33.37285675781557, },
        { date: "Jan 1 2010 17:00:00 GMT-0700 (Pacific Daylight Time)", val1: 59.79389691673664, val2: 40.20610308326336, },
        { date: "Jan 1 2009 17:00:00 GMT-0700 (Pacific Daylight Time)", val1: 73.67210500642548, val2: 26.327894993574525, },
        { date: "Jan 1 2008 17:00:00 GMT-0700 (Pacific Daylight Time)", val1: 75.05648974856052, val2: 24.943510251439474, },
        { date: "Jan 1 2007 17:00:00 GMT-0700 (Pacific Daylight Time)", val1: 78.4968369374039, val2: 21.5031630625961, },
        { date: "Jan 1 2006 17:00:00 GMT-0700 (Pacific Daylight Time)", val1: 79.42261755214523, val2: 20.577382447854763, },
        { date: "Jan 1 2005 17:00:00 GMT-0700 (Pacific Daylight Time)", val1: 71.46115452064461, val2: 28.53884547935539, },
        { date: "Jan 1 2004 17:00:00 GMT-0700 (Pacific Daylight Time)", val1: 82.11210746842087, val2: 17.887892531579137, },
        { date: "Jan 1 2003 17:00:00 GMT-0700 (Pacific Daylight Time)", val1: 79.21905621001227, val2: 20.780943789987735, },
        { date: "Jan 1 2002 17:00:00 GMT-0700 (Pacific Daylight Time)", val1: 83.67151093351666, val2: 16.328489066483336, },
        { date: "Jan 1 2001 17:00:00 GMT-0700 (Pacific Daylight Time)", val1: 83.91185588078507, val2: 16.088144119214924, },
        { date: "Jan 1 2000 17:00:00 GMT-0700 (Pacific Daylight Time)", val1: 88.47459216168933, val2: 11.525407838310677, }

    ]

    const BLUE = 'rgba(0, 95, 158, 1)';
    const BLUE50 = 'rgba(0, 95, 155, .3)';
    const BLUE0 = 'rgba(0, 95, 155, 0)';
    const BLUE_GRADIENT = 'url(#BLUE-grad)';

    const SKY = '#B42573';
    const SKY50 = '#B4257330';
    const SKY0 = '#B4257300';
    const SKY_GRADIENT = 'url(#SKY-grad)';

    let zoomed = false;
    let filled = false;
    let lowDate = null;
    let highDate = null;

    data.forEach(el => {
        el.date = new Date(el.date)
    });

    const maxYear = d3.max(data, d => d.date).getFullYear();
    const minYear = d3.min(data, d => d.date).getFullYear();
    const middleOfData = (new Date((d3.min(data, d => d.date).getTime() + d3.max(data, d => d.date).getTime()) / 2));
    const totalYearsInData = Math.round((maxYear - minYear));
    const zoomWidth = Math.round(totalYearsInData / 3); // We arbitrarily zoom in to 3x, which shows us 1/3 of the data when zoomed
    const halfZoom = Math.round(zoomWidth / 2); // this is the number of years above/below the midpoint when zoomed

    const oneYear = 31536000000;

    // set the dates for zooming into the middle of the data (when clicking zoom in before interacting with the chart)
    let oldLowDate = new Date(String(middleOfData.getFullYear() - halfZoom));
    let oldHighDate = new Date(String(middleOfData.getFullYear() + halfZoom));

    //************************** D3    CHARTS ***************************************************//
    //******************************************************************************************//

    class drawChart {
        constructor() {
            this.draws = 0;
            this.data = data;
            this.initVis();
        }
        initVis() {
            const vis = this;

            // CHART
            vis.chartDiv = document.getElementById("chart");
            vis.svg = d3.select(vis.chartDiv).append("svg");

            // APPEND G
            vis.g = vis.svg
                .append('g')
                .attr('class', 'g3')

            vis.dashedLines = vis.g.append('g')

            // APPEND LINE
            vis.lineOne = vis.g
                .append('path')
                .attr('stroke', BLUE)
                .attr('stroke-width', 2)
                .attr('fill', 'none')

            // ADD AREA
            vis.areaOne = vis.g.append("path")
                .attr('fill', BLUE_GRADIENT);

            // APPEND LINE
            vis.lineTwo = vis.g
                .append('path')
                .attr('stroke', SKY)
                .attr('stroke-width', 2)
                .attr('fill', 'none')

            // ADD AREA
            vis.areaTwo = vis.g.append("path")
                .attr('fill', SKY_GRADIENT);

            // APPEND WHITE BOX TO COVER AREA WHEN CHART EXPANDS DURING ZOOM
            // vis.whiteBox = vis.g
            //     .append('rect')
            //     .attr('fill', 'white')
            //     .attr('width', 25)
            //     .attr('y', 0)

            // APPEND X AXIS 
            vis.xAxis = vis.g
                .append('g')
                .attr('class', 'axis x-axis p-14 demi')

            // APPEND Y AXIS 
            vis.yAxis = vis.g
                .append('g')
                .style('text-anchor', 'end')
                .attr('class', 'axis y-axis p-14 demi')

            // DEFINE LINEAR GRADIENT
            vis.gradient = vis.svg
                .append('linearGradient')
                .attr('id', 'SKY-grad')
                .attr('x1', 0)
                .attr('y1', 0)
                .attr('x2', 0)
                .attr('y2', 1)
                .attr('gradientUnits', 'objectBoundingBox');
            vis.gradient
                .append('stop')
                .attr('offset', '0')
                .attr('stop-color', SKY50);
            vis.gradient
                .append('stop')
                .attr('offset', '1')
                .attr('stop-color', SKY0);

            // DEFINE LINEAR GRADIENT
            vis.gradient = vis.svg
                .append('linearGradient')
                .attr('id', 'BLUE-grad')
                .attr('x1', 0)
                .attr('y1', 0)
                .attr('x2', 0)
                .attr('y2', 1)
                .attr('gradientUnits', 'objectBoundingBox');
            vis.gradient
                .append('stop')
                .attr('offset', '0')
                .attr('stop-color', BLUE50);
            vis.gradient
                .append('stop')
                .attr('offset', '1')
                .attr('stop-color', BLUE0);

            // FINALLY, APPEND A TOUCH LAYER TO BYPASS ALL OF OUR TEXT AND OTHER DIVS THAT HAVE BEEN APPENDED
            vis.touchLayer = d3.select('#chart').append('div').attr('class', 'touch-layer');

            this.wrangle();
        }

        wrangle(x1 = d3.min(this.data, d => d.date), x2 = d3.max(this.data, d => d.date)) {
            const vis = this;

            // Extract the width and height that was computed by CSS.
            vis.width = vis.chartDiv.clientWidth;
            vis.height = vis.chartDiv.clientHeight;
            vis.bottom = vis.width * .02;
            vis.top = 8;
            vis.MARGIN = { top: vis.top, right: 20, bottom: vis.bottom, left: vis.width * .04 };
            vis.gWIDTH = vis.width - (vis.MARGIN.left + vis.MARGIN.right);
            vis.gHEIGHT = vis.height - (vis.MARGIN.top + vis.MARGIN.bottom);

            // X SCALE
            vis.x = d3
                .scaleTime()
                .domain([x1, x2.getTime() + oneYear / 24])
                .range([0, vis.gWIDTH])

            lowDate = x1;
            highDate = x2;

            // HANDLE CLICKS ///////////////////////////////////////////
            const svgElement = document.querySelector('#chart svg')

            let holding = false;
            let clickOne = null;
            let difference = 0;

            vis.touchLayer.on("mousedown", handleStart);
            vis.touchLayer.on("touchstart", handleStart);

            // attach the mousemove and mouseup to the body in case one wonders off the svg (we use body)
            vis.touchLayer.on("mousemove", handleMove).on("mouseup", handleEnd).on('mouseout', handleEnd)
            vis.touchLayer.on("touchmove", handleMove).on("touchend", handleEnd).on("touchcancel", handleEnd)

            function handleStart() {
                if (zoomed) {
                    clickOne = d3.mouse(svgElement)[0];
                    holding = true;
                }
            }

            // sometimes it's hard to drag your way all the way to the very end of the chart, but if you move the opposite way it works
            let moveTrigger = 0;
            const overflow = oneYear / 5;
            function handleMove() {
                if (zoomed && holding) {
                    d3.event.preventDefault();

                    const clickTwo = d3.mouse(svgElement)[0]
                    const date1 = vis.x.invert(clickOne)
                    const date2 = vis.x.invert(clickTwo)

                    difference = ((date2 - date1));

                    if (lowDate.getTime() - difference > d3.min(vis.data, d => d.date).getTime() - overflow) {
                        if (highDate.getTime() - difference < d3.max(vis.data, d => d.date).getTime() + overflow) {
                            vis.x.domain([lowDate.getTime() - difference, highDate.getTime() - difference])
                            vis.redraw(true)
                        } else {
                            moveTrigger += 1;
                            if (moveTrigger === 30) {
                                moveTrigger = 0;
                                vis.x.domain([d3.max(vis.data, d => d.date).getTime() + overflow - zoomWidth * oneYear, d3.max(vis.data, d => d.date).getTime() + overflow])
                                vis.redraw(true)
                            }
                        }

                    } else {
                        moveTrigger += 1;
                        if (moveTrigger === 30) {
                            moveTrigger = 0;
                            vis.x.domain([d3.min(vis.data, d => d.date).getTime() - overflow, d3.min(vis.data, d => d.date).getTime() - overflow + zoomWidth * oneYear])
                            vis.redraw(true)
                        }
                    }
                }
            }

            function handleEnd() {
                if (zoomed && holding) {
                    if (lowDate.getTime() - difference < d3.min(vis.data, d => d.date).getTime() - overflow) {
                        lowDate = new Date(d3.min(vis.data, d => d.date).getTime() - overflow)
                        highDate = new Date(d3.min(vis.data, d => d.date).getTime() - overflow + zoomWidth * oneYear)
                    } else if (highDate.getTime() - difference > d3.max(vis.data, d => d.date).getTime() + overflow) {
                        lowDate = new Date(d3.max(vis.data, d => d.date).getTime() + overflow - zoomWidth * oneYear)
                        highDate = new Date(d3.max(vis.data, d => d.date).getTime() + overflow)
                    } else {
                        lowDate = new Date(lowDate.getTime() - difference)
                        highDate = new Date(highDate.getTime() - difference)
                    }
                }
                holding = false;
            }

            vis.redraw()

            // if (zoomed)
            //     document.querySelector('.p-chart').style.overflow = 'hidden'
            // else {
            //     setTimeout(() => {
            //         document.querySelector('.p-chart').style.overflow = 'none'
            //     }, 1000);
            // }
        }

        redraw(pan = false) {

            const seismicApp = window.innerWidth < 1100;

            const vis = this;
            vis.draws += 1;

            // Use the extracted size to set the size of an SVG element.
            vis.svg
                .attr("width", vis.width)
                .attr("height", vis.height);

            // SET SIZE FOR TOUCH LAYER
            vis.touchLayer
                .style("width", vis.width + 'px')
                .style("height", vis.height + 'px')
                .attr("pointer-events", "all");

            // SET G
            vis.g.attr('width', vis.gWIDTH)
                .attr('height', vis.gHEIGHT)
                .attr('transform', 'translate(' + vis.MARGIN.left + ',' + vis.MARGIN.top + ')');

            ///////////////////////////////////////////////////////
            const x = vis.x;

            let yMax = 100;
            let yMin = 0;

            const y = d3.scaleLinear()
                .range([vis.gHEIGHT, 0])
                .domain([yMin, yMax]);

            const lineOne = d3.line()
                .x(d => x(d.date))
                .y(d => y(d.val1));
            const areaOne = d3.area()
                .x(d => x(d.date))
                .y1(d => y(yMin))
                .y0(d => y(d.val1))

            const lineTwo = d3.line()
                .x(d => x(d.date))
                .y(d => y(d.val2));
            const areaTwo = d3.area()
                .x(d => x(d.date))
                .y1(d => y(yMin))
                .y0(d => y(d.val2))

            const flatArea = d3.area()
                .x(d => x(d.date))
                .y1(d => y2(yMin))
                .y0(d => y2(yMin))

            // creates a flat starting path to start the animation
            let startLine = vis.data.map(k => {
                return { date: k.date, val1: yMin, val2: yMin };
            });

            ////////////////// LINE BLUE
            if (vis.draws <= 1) {
                vis.lineOne
                    .attr('d', lineOne(startLine))
                    .transition()
                    .duration(1500)
                    .delay(0)
                    .attr('d', lineOne(vis.data))
            } else {
                if (pan) {
                    vis.lineOne
                        .attr('d', lineOne(vis.data))
                } else {
                    vis.lineOne
                        .transition()
                        .duration(1000)
                        .delay(0)
                        .attr('d', lineOne(vis.data))
                }
            }

            ////////////////// LINE BLUE
            if (vis.draws <= 1) {
                vis.lineTwo
                    .attr('d', lineTwo(startLine))
                    .transition()
                    .duration(1500)
                    .delay(0)
                    .attr('d', lineTwo(vis.data))
            } else {
                if (pan) {
                    vis.lineTwo
                        .attr('d', lineTwo(vis.data))
                } else {
                    vis.lineTwo
                        .transition()
                        .duration(1000)
                        .delay(0)
                        .attr('d', lineTwo(vis.data))
                }
            }

            // BLUE AREA
            if (vis.draws <= 1) {
                vis.areaOne
                    // .attr('d', flatArea(vis.data))
                    // .transition()
                    // .duration(1500)
                    // .delay(0)
                    .attr('d', areaOne(vis.data))
                    .attr('opacity', 0)
            } else {
                if (pan) {
                    vis.areaOne
                        .attr('d', areaOne(vis.data))
                        .attr('opacity', filled ? 1 : 0)
                } else {
                    vis.areaOne
                        .transition()
                        .duration(1000)
                        .delay(0)
                        .attr('d', areaOne(vis.data))
                        .attr('opacity', filled ? 1 : 0)
                }
            }

            // BLUE AREA
            if (vis.draws <= 1) {
                vis.areaTwo
                    // .attr('d', flatArea(vis.data))
                    // .transition()
                    // .duration(1500)
                    // .delay(0)
                    .attr('d', areaTwo(vis.data))
                    .attr('opacity', 0)
            } else {
                if (pan) {
                    vis.areaTwo
                        .attr('d', areaTwo(vis.data))
                        .attr('opacity', filled ? 1 : 0)
                } else {
                    vis.areaTwo
                        .transition()
                        .duration(1000)
                        .delay(0)
                        .attr('d', areaTwo(vis.data))
                        .attr('opacity', filled ? 1 : 0)
                }
            }

            const tickVals = []
            for (let i = 2001; i <= 2021; i = i + 5) {
                tickVals.push(new Date('Jan 1 ' + String(i) + ' 16:00:21 GMT-0700 (Pacific Daylight Time)'))
            }

            //////////////////////////////// X AXIS
            const xAxisCall = d3.axisBottom()
                .tickValues(tickVals)
                .tickPadding(4)
                .tickSizeOuter([0])
                .tickFormat(e => e.getFullYear());

            if (vis.draws <= 1) {
                vis.xAxis
                    .call(xAxisCall.scale(x))
                    .attr('transform', `translate(0, ${y(yMin)})`)
                    .transition()
                    .duration(2500)
                    .delay(100)
                    .attr('transform', `translate(0, ${y(yMin)})`)
            } else {
                if (pan) {
                    vis.xAxis
                        .attr('transform', `translate(0, ${y(yMin)})`)
                        .call(xAxisCall.scale(x))

                } else {
                    if (zoomed) {
                        vis.xAxis
                            .transition()
                            .delay(0)
                            .duration(1000)
                            .attr('transform', `translate(0, ${y(yMin)})`)
                            .call(xAxisCall.scale(x))
                    } else {
                        vis.xAxis
                            .transition()
                            .delay(0)
                            .duration(1000)
                            .attr('transform', `translate(0, ${y(yMin)})`)
                            .call(xAxisCall.scale(x))
                    }
                }
            }

            //////////////////////////////// Y AXIS
            let xOffset = 0;
            const yAxisCall = d3.axisLeft()
                .ticks(10)
                .tickPadding(-vis.MARGIN.left * .6)
                .tickFormat(e => e === 100 ? e + '%' : e)

            if (vis.draws <= 1) {
                vis.yAxis
                    .attr('transform', `translate(${xOffset - vis.MARGIN.left},0)`)
                    .call(yAxisCall.scale(y).tickSizeOuter([0]))
            } else {
                vis.yAxis
                    .transition()
                    .delay(0)
                    .duration(1000)
                    .attr('transform', `translate(${xOffset - vis.MARGIN.left},0)`)
                    .call(yAxisCall.scale(y).tickSizeOuter([0]))

            }

            const dashedLines = vis.dashedLines.selectAll('line').data([100, 90, 80, 70, 60, 50, 40, 30, 20, 10])

            dashedLines.exit().remove()

            dashedLines
                .attr('x1', 0)
                .attr('y1', d => y(d))
                .attr('x2', vis.width)
                .attr('y2', d => y(d))
                .style('opacity', 1)

            dashedLines
                .enter()
                .append('line')
                .attr('stroke', d => d === 100 || d === 50 ? '#96999C90' : '#96999C70')
                .attr('stroke-width', 1)
                .attr('stroke-dasharray', d => d === 100 || d === 50 ? 'initial' : '3 3')
                .attr('x1', 0)
                .attr('y1', d => y(d))
                .attr('x2', vis.width)
                .attr('y2', d => y(d))
                .style('opacity', 0)
                .transition()
                .duration(1500)
                .delay((d, i) => d * i + 555)
                .style('opacity', 1)

            // vis.whiteBox.attr('height', vis.height).attr('x', -vis.MARGIN.left)

        } // end redraw
    } //end class
    //*************************************************************************************************//
    //*************************************************************************************************//

    const chart = new drawChart();

    window.addEventListener("resize", () => redraw());

    function redraw() {
        chart.wrangle(lowDate, highDate);
    }

</script>

</html>