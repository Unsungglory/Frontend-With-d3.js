<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="initial-scale = 1, user-scalable = no" />

    <link href="./engine/css/normalize.css" rel="stylesheet" type="text/css" />
    <link href="./engine/css/master.css" rel="stylesheet" type="text/css">

    <!-- Jquery -->
    <!-- <script src="./engine/js/jquery-3.4.1.min.js" type="text/javascript"></script> -->

    <!-- websiteInfo -->
    <script src="./websiteInfo.js" type="text/javascript"></script>

    <!-- ADD FUND TILES -->
    <script>
        const addFundTiles = true;
    </script>

    <!-- Add Scripts -->
    <script defer src="./engine/js/init.js"></script>

    <!-- ADD SMA FUNCTIONALITY -->
    <link href="./SMA/css/sma.css" rel="stylesheet" type="text/css" />
    <script src="./SMA/sma.js" type="text/javascript"></script>


    <style>

.title-wrapper-a h2,
        .title-wrapper-2 h2 {
            line-height: 1.15;
        }

        .domain {
            display: none;
        }

        .toggle-wrapper path {
            transition: .5s fill ease-in-out;
        }

        .toggle-wrapper {
            position: relative;
            left: -6%;
        }

        .axis {
            color: rgba(0, 0, 0, .9);
        }

        .x-axis .tick {
            text-anchor: middle;
        }

        .x-axis .tick line {
            display: initial;
        }

        .title-wrapper-2 {
            grid-template-columns: 69% 27%;
            column-gap: 5%;

        }


        @media (max-width: 1300px) {}
    </style>
</head>

<body>

    <!-- page content -->
    <div id="master-float">

        <div id="master-container">
            <!-- navigation -->
            <div id="nav-container"></div>
            <!-- end navigation -->

            <section id="content-size-setter">
                <section id="content-padding">
                    <section id='content-area'>

                        <!-- content title -->
                        <div class="title-wrapper-2">
                            <div>
                                <h1>
                                    Equity markets have historically powered through geopolitical events
                                </h1>
                                

                            </div>

                        </div>
                        <!-- end content title -->


                        <div id='main-page-content'>
                            <!-- chart title & legend area -->
                            <section class="chart-ui-row">

                                <div class="chart-title-wrapper">
                                    <h3>S&P 500 index levels (logarithmic scale)</h3>
                                    
                                </div>

                                <div style='display: flex;'>
                                    <div class="toggle-wrapper">
                                        <div class="p-btn-label p-12 ls-1p2 demi"
                                            style="color: rgba(127, 127, 127, 1);">
                                            LINE STYLE</div>
                                        <toggle class="line-toggle-pill">
                                            <div id="toggle-slider" class="w50" style='left: 0%;'></div>
                                            <button onclick="toggleLine()" class="toggle-on">
                                                <svg xmlns="http://www.w3.org/2000/svg" width="21.216" height="13.769"
                                                    viewBox="0 0 21.216 13.769">
                                                    <path id='line' style="fill:rgba(0,41,75, .9);"
                                                        d="M3.591,19.279,9.956,12.9,14.2,17.147,23.216,7.006l-1.5-1.5L14.2,13.965,9.956,9.721,2,17.688Z"
                                                        transform="translate(-2 -5.51)"></path>
                                                </svg>
                                            </button>
                                            <button onclick="toggleFill()">
                                                <svg xmlns="http://www.w3.org/2000/svg" width="27" height="14"
                                                    viewBox="0 0 27 14">
                                                    <g transform="translate(-0.429 -8.335)">
                                                        <path id='mountain' fill="rgba(0,41,75,0.3)" d="M9.5,0,19,14H0Z"
                                                            transform="translate(8.429 8.335)"></path>
                                                        <path id='mountain-2' fill="rgba(0, 95, 158, 0.3)"
                                                            d="M7.5,0,15,10H0Z" transform="translate(0.429 12.335)">
                                                        </path>
                                                    </g>
                                                </svg>
                                            </button>
                                        </toggle>
                                    </div>
                                    <div class="zoom-btn-container">
                                        <div class="p-btn-label">ZOOM</div>
                                        <div class="zoom-btn">
                                            <button id="zoom-plus" onclick="zoomIn()">+</button>
                                            <button id="zoom-minus" onclick="zoomOut()">
                                                <div style="transform: scaleX(1.6)">–</div>
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </section>

                            <!-- end chart title & legend area -->

                            <!-- chart -->
                            <section class="chart-wrapper-a">
                                <div class='' id="chart"></div>
                            </section>
                            <!-- end chart -->

                            <!-- disclosure content -->
                            <div id="disclosure-wrapper">
                            <p>
                                Sources: Capital Group, Refinitiv Datastream, Standard & Poor’s. Chart shown on a logarithmic scale. Index levels reflect price returns, and do not include the impact of dividends. As of January 31, 2022.
                            </p>
                            <p>
                                Standard & Poor's 500 Composite Index is a market capitalization-weighted index based on the results of approximately 500 widely held common stocks. This index is unmanaged, and its results include reinvested dividends and/or distributions but do not reflect the effect of sales charges, commissions, account fees, expenses or U.S. federal income taxes. Investors cannot invest directly in an index.
                            </p>
                            <p>
                                The Standard & Poor’s 500 Composite Index is a product of S&P Dow Jones Indices LLC and/or its affiliates and has been licensed for use by Capital Group. Copyright © 2022 S&P Dow Jones Indices LLC, a division of S&P Global, and/or its affiliates. All rights reserved. Redistribution or reproduction in whole or in part are prohibited without written permission of S&P Dow Jones Indices LLC
                            </p>
                            <p>
                                <span>Investors should carefully consider investment objectives, risks, charges and expenses. This and other important information is contained in the fund prospectuses and summary prospectuses, which can be obtained from a financial professional and should be read carefully before investing.</span>
                            </p>
                            <p>
                                Statements attributed to an individual represent the opinions of that individual as of the date published and do not necessarily reflect the opinions of Capital Group or its affiliates. This information is intended to highlight issues and should not be considered advice, an endorsement or a recommendation.
                            </p>
                            <p>
                                This content, developed by Capital Group, home of American Funds, should not be used as a primary basis for investment decisions and is not intended to serve as impartial investment or fiduciary advice.
                            </p>
                            <p>
                                All Capital Group trademarks mentioned are owned by The Capital Group Companies, Inc., an affiliated company or fund. All other company and product names mentioned are the property of their respective companies.
                            </p>
                            <p>
                                American Funds Distributors, Inc., member FINRA.
                            </p>
                            <p>
                                © 2022 Capital Group. All rights reserved.
                                </p>
                            </div>
                            <!-- end disclosure content -->
                        </div>
                    </section>

                </section>
            </section>
        </div>
    </div>
    <!-- end page content -->
</body>

<script src="engine/js/d3.min.js"></script>
<script src="./data/line2.js"></script>

<script>

    // Gradients
    const SAPPH = 'rgba(0, 95, 158, 1)';
    const SAPPH50 = 'rgba(0, 95, 158, 0.4)';
    const SAPPH0 = 'rgba(0, 95, 158, 0)';

    const colorTwo = 'rgba(0, 0, 0, 1)';
    const colorTwo50 = 'rgba(0, 0, 0, .15)';
    const colorTwo0 = 'rgba(0, 0, 0, 0)';

    // const BONE = 'rgba(213, 208, 202, 1)';
    const BONE50 = 'rgba(213, 208, 202, 0.30)';

    const SAPPH_GRADIENT = 'url(#SAPPH-grad)';

    let zoomed = false;
    let filled = false;
    let lowDate = null;
    let highDate = null;

    data.forEach(el => {
        el.date = new Date(el.date)
    });

    const maxYear = d3.max(data, d => d.date).getFullYear();
    const minYear = d3.min(data, d => d.date).getFullYear();
    const middleOfData = (new Date((d3.min(data, d => d.date).getTime() + d3.max(data, d => d.date).getTime()) / 2));
    const totalYearsInData = Math.round((maxYear - minYear));

    const oneYear = 31536000000;
    const oneMonth = oneYear / 12;

    const zoomWidth = Math.round(12 / 3); // We arbitrarily zoom in to 3x, which shows us 1/3 of the data when zoomed
    const halfZoom = oneYear * 7; // this is the number of years above/below the midpoint when zoomed

    console.warn(maxYear, minYear, middleOfData, totalYearsInData, zoomWidth, halfZoom)

    // set the dates for zooming into the middle of the data (when clicking zoom in before interacting with the chart)
    let oldLowDate = new Date((middleOfData.getTime() - halfZoom));
    let oldHighDate = new Date((middleOfData.getTime() + halfZoom));

    //************************** D3    CHARTS ***************************************************//
    //******************************************************************************************//

    class drawChart {
        constructor() {
            this.draws = 0;
            this.data = data;
            this.info = [
                { name: 'Iran hostage crisis', date: '11/30/1979', pos: 'u' },
                { name: 'Iran-Contra affair', date: '11/28/1986', pos: 'u' },
                { name: 'Iraq invades Kuwait', date: '8/31/1990', pos: 'd' },
                { name: 'First Gulf War', date: '1/31/1991', pos: 'u' },
                { name: '9/11', date: '9/28/2001', pos: 'd' },
                { name: 'Second Gulf War', date: '3/31/2003', pos: 'u' },
                { name: 'Orange Revolution-Ukraine', date: '11/30/2004', pos: 'dd' },
                { name: 'London Bombings', date: '7/29/2005', pos: 'u' },
                { name: 'Arab Spring', date: '12/31/2010', pos: 'u' },
                { name: 'Russia invades Crimea', date: '2/28/2014', pos: 'u' },
                { name: 'Brexit', date: '6/30/2016', pos: 'd' },
                { name: 'US-China trade war', date: '1/31/2018', pos: 'u' },
            ]
            this.initVis();
        }

        initVis() {
            const vis = this;

            // CHART
            vis.chartDiv = document.getElementById("chart");
            vis.svg = d3.select(vis.chartDiv).append("svg").attr('id', 'g-line');

            // APPEND G
            vis.g = vis.svg
                .append('g')
                .attr('class', 'g3')

            vis.zeroLine = vis.g
                .append('line')
                .attr('class', 'zero-line')

            // APPEND LINE
            vis.lineTwo = vis.g
                .append('path')
                .attr('stroke', '#005F9E')
                .attr('stroke-width', 2)
                .attr('fill', 'none')

            // ADD AREA
            vis.blueArea = vis.g.append("path")
                .attr('fill', SAPPH_GRADIENT);

            vis.lines = vis.g
                .append('g')
                .attr('class', 'lines')

            vis.dots = vis.g
                .append('g')
                .attr('class', 'dots')

            vis.texts = vis.g
                .append('g')
                .attr('class', 'texts')

            // APPEND WHITE BOX TO COVER AREA WHEN CHART EXPANDS DURING ZOOM
            vis.whiteBox = vis.g
                .append('rect')
                .attr('class', 'whiteBox')
                .attr('fill', '#f8f8f8')
                .attr('width', 33)
                .attr('y', 0)

            // APPEND X AXIS 
            vis.xAxis = vis.g
                .append('g')
                .attr('class', 'axis x-axis p-16')

            // APPEND Y AXIS 
            vis.yAxis = vis.g
                .append('g')
                .style('text-anchor', 'start')
                .attr('class', 'axis y-axis p-16')

            // DEFINE LINEAR GRADIENT
            vis.gradient = vis.svg
                .append('linearGradient')
                .attr('id', 'SAPPH-grad')
                .attr('x1', 0)
                .attr('y1', 0.2)
                .attr('x2', 0)
                .attr('y2', 1)
                .attr('gradientUnits', 'objectBoundingBox');
            vis.gradient
                .append('stop')
                .attr('offset', '0')
                .attr('stop-color', SAPPH50);
            vis.gradient
                .append('stop')
                .attr('offset', '1')
                .attr('stop-color', SAPPH0);

            vis.gradient = vis.svg
                .append('linearGradient')
                .attr('id', 'second-grad')
                .attr('x1', 0)
                .attr('y1', 0.2)
                .attr('x2', 0)
                .attr('y2', 1)
                .attr('gradientUnits', 'objectBoundingBox');
            vis.gradient
                .append('stop')
                .attr('offset', '0')
                .attr('stop-color', colorTwo50);
            vis.gradient
                .append('stop')
                .attr('offset', '1')
                .attr('stop-color', colorTwo0);

            // FINALLY, APPEND A TOUCH LAYER TO BYPASS ALL OF OUR TEXT AND OTHER DIVS THAT HAVE BEEN APPENDED
            vis.touchLayer = d3.select('#chart').append('div').attr('class', 'touch-layer').style('position', 'absolute');

            this.wrangle();
        }

        wrangle(x1 = new Date("1/1/1974 00:00:00 GMT-0800 (Pacific Standard Time)"), x2 = d3.max(this.data, d => d.date)) {
            const vis = this;

            // Extract the width and height that was computed by CSS.
            vis.width = vis.chartDiv.clientWidth;
            vis.height = vis.chartDiv.clientHeight;
            vis.top = 14;
            vis.MARGIN = { top: vis.top, right: 0, bottom: vis.height * .066, left: vis.width * .02 };
            vis.gWIDTH = vis.width - (vis.MARGIN.left + vis.MARGIN.right);
            vis.gHEIGHT = vis.height - (vis.MARGIN.top + vis.MARGIN.bottom);

            // X SCALE
            vis.x = d3
                .scaleTime()
                .domain([x1, x2])
                .range([0, vis.gWIDTH])

            lowDate = x1
            highDate = x2;

            // HANDLE CLICKS ///////////////////////////////////////////
            const svgElement = document.querySelector('#chart svg')

            let holding = false;
            let clickOne = null;
            let difference = 0;

            vis.touchLayer.on("mousedown", handleStart);
            vis.touchLayer.on("touchstart", handleStart);

            // attach the mousemove and mouseup to the body in case one wonders off the svg (we use body)
            vis.touchLayer.on("mousemove", handleMove).on("mouseup", handleEnd).on('mouseout', handleEnd)
            vis.touchLayer.on("touchmove", handleMove).on("touchend", handleEnd).on("touchcancel", handleEnd)

            function handleStart() {
                if (zoomed) {
                    clickOne = d3.mouse(svgElement)[0];
                    holding = true;
                }
            }

            // sometimes it's hard to drag your way all the way to the very end of the chart, but if you move the opposite way it works
            let moveTrigger = 0;
            const overflow = oneMonth * 6;
            function handleMove() {
                if (zoomed && holding) {
                    d3.event.preventDefault();

                    const clickTwo = d3.mouse(svgElement)[0]
                    const date1 = vis.x.invert(clickOne)
                    const date2 = vis.x.invert(clickTwo)

                    difference = ((date2 - date1));

                    if (lowDate.getTime() - difference > d3.min(vis.data, d => d.date).getTime() - overflow) {
                        if (highDate.getTime() - difference < d3.max(vis.data, d => d.date).getTime() + overflow) {
                            vis.x.domain([lowDate.getTime() - difference, highDate.getTime() - difference])
                            vis.redraw(true)
                        } else {
                            moveTrigger += 1;
                            if (moveTrigger === 30) {
                                moveTrigger = 0;
                                vis.x.domain([d3.max(vis.data, d => d.date).getTime() + overflow - zoomWidth * (oneMonth * 12 * 5), d3.max(vis.data, d => d.date).getTime() + overflow])
                                vis.redraw(true)
                            }
                        }

                    } else {
                        moveTrigger += 1;
                        if (moveTrigger === 30) {
                            moveTrigger = 0;
                            vis.x.domain([d3.min(vis.data, d => d.date).getTime() - overflow, d3.min(vis.data, d => d.date).getTime() - overflow + zoomWidth * (oneMonth * 12 * 5)])
                            vis.redraw(true)
                        }
                    }
                }
            }

            function handleEnd() {
                if (zoomed && holding) {
                    if (lowDate.getTime() - difference < d3.min(vis.data, d => d.date).getTime() - overflow) {
                        lowDate = new Date(d3.min(vis.data, d => d.date).getTime() - overflow)
                        highDate = new Date(d3.min(vis.data, d => d.date).getTime() - overflow + zoomWidth * (oneMonth * 12 * 5))
                    } else if (highDate.getTime() - difference > d3.max(vis.data, d => d.date).getTime() + overflow) {
                        lowDate = new Date(d3.max(vis.data, d => d.date).getTime() + overflow - zoomWidth * (oneMonth * 12 * 5))
                        highDate = new Date(d3.max(vis.data, d => d.date).getTime() + overflow)
                    } else {
                        lowDate = new Date(lowDate.getTime() - difference)
                        highDate = new Date(highDate.getTime() - difference)
                    }
                }
                holding = false;
            }

            vis.redraw()
        }

        redraw(pan = false) {
            const vis = this;
            const seismicApp = window.innerWidth < 1100;

            vis.draws += 1;

            // Use the extracted size to set the size of an SVG element.
            vis.svg
                .attr("width", vis.width)
                .attr("height", vis.height);

            // SET SIZE FOR TOUCH LAYER
            vis.touchLayer
                .style("width", vis.width + 'px')
                .style("height", vis.height + 'px')
                .style("top", 0)
                .attr("pointer-events", "all")

            // SET G
            vis.g.attr('width', vis.gWIDTH)
                .attr('height', vis.gHEIGHT)
                .attr('transform', 'translate(' + vis.MARGIN.left + ',' + vis.MARGIN.top + ')');

            ///////////////////////////////////////////////////////
            const x = vis.x;

            let yMax = 6400;
            let yMin = 45;

            const y = d3.scaleLog()
                .range([vis.gHEIGHT, 0])
                .domain([yMin, yMax]);

            // ****************  LINE FUNCTIONS ****************************
            const generateLine = d3.line()
                .x(d => x(d.date))
                .y(d => y(d.val));

            // **************** END LINE FUNCTIONS ****************************
            const generateArea = d3.area()
                .x(d => x(d.date))
                .y1(d => y(50))
                .y0(d => y(d.val))

            // ////////////////////////////////////////////////////////////////
            const flatArea = d3.area()
                .x(d => x(d.date))
                .y1(d => y2(50))
                .y0(d => y2(50))

            // creates a flat starting path to start the animation
            let startLine = vis.data.map(k => {
                return { date: k.date, val: 50 };
            });

            ////////////////// LINES 
            if (vis.draws <= 1) {

                vis.lineTwo
                    .attr('d', generateLine(startLine))
                    .transition()
                    .duration(1500)
                    .delay(333)
                    .attr('d', generateLine(vis.data))

            } else {
                if (pan) {

                    vis.lineTwo
                        .attr('d', generateLine(vis.data))

                } else {

                    vis.lineTwo
                        .transition()
                        .duration(1000)
                        .attr('d', generateLine(vis.data))
                }
            }

            // AREA
            if (vis.draws <= 1) {
                null
            } else {
                if (pan) {
                    vis.blueArea
                        .attr('d', generateArea(vis.data))
                        .attr('opacity', filled ? 1 : 0);

                } else {
                    vis.blueArea
                        .transition()
                        .duration(1000)
                        .delay(0)
                        .attr('d', generateArea(vis.data))
                        .attr('opacity', filled ? 1 : 0);
                }
            }

            const tickVals = [
                new Date("1/1/1975 00:00:00 GMT-0800 (Pacific Standard Time)"),
                new Date("1/1/1980 00:00:00 GMT-0800 (Pacific Standard Time)"),
                new Date("1/1/1985 00:00:00 GMT-0800 (Pacific Standard Time)"),
                new Date("1/1/1990 00:00:00 GMT-0800 (Pacific Daylight Time)"),
                new Date("1/1/1995 00:00:00 GMT-0800 (Pacific Daylight Time)"),
                new Date("1/1/2000 00:00:00 GMT-0800 (Pacific Daylight Time)"),
                new Date("1/1/2005 00:00:00 GMT-0800 (Pacific Daylight Time)"),
                new Date("1/1/2010 00:00:00 GMT-0800 (Pacific Daylight Time)"),
                new Date("1/1/2015 00:00:00 GMT-0800 (Pacific Daylight Time)"),
                new Date("1/1/2020 00:00:00 GMT-0800 (Pacific Daylight Time)"),
            ]

            //////////////////////////////// X AXIS
            const monthLookup = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'June', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
            const xAxisCall = d3.axisBottom()
                .tickPadding(vis.height * .02)
                .tickValues(tickVals)
                .tickSizeInner([10])
                .tickSizeOuter([10])
                .tickFormat(e => {
                    return e.getFullYear()
                });

            const xLabelPos = y(50)
            if (vis.draws === 1) {
                vis.xAxis
                    .call(xAxisCall.scale(x))
                    .attr('transform', `translate(${0}, ${xLabelPos})`)
                    .style('opacity', 0)
                    .transition()
                    .duration(2500)
                    .delay(100)
                    .attr('transform', `translate(${0}, ${xLabelPos})`)
                    .style('opacity', 1)

            } else {
                if (pan) {
                    vis.xAxis
                        .attr('transform', `translate(0, ${xLabelPos})`)
                        .call(xAxisCall.scale(x))
                        .style('opacity', 1)

                } else {
                    if (zoomed) {
                        vis.xAxis
                            .transition()
                            .delay(0)
                            .duration(1000)
                            .attr('transform', `translate(${0}, ${xLabelPos})`)
                            .call(xAxisCall.scale(x))
                            .style('opacity', 1)
                    } else {
                        vis.xAxis
                            .transition()
                            .delay(0)
                            .duration(1000)
                            .attr('transform', `translate(${0}, ${xLabelPos})`)
                            .call(xAxisCall.scale(x))
                            .style('opacity', 1)
                    }
                }
            }

            //////////////////////////////// Y AXIS
            let xOffset = seismicApp ? 9 : 10;
            const yAxisCall = d3.axisLeft()
                .tickValues([50, 100, 200, 400, 800, 1600, 3200, 6400])
                .tickFormat(e => {
                    return e
                })

            if (vis.draws === 1) {
                vis.yAxis
                    .attr('transform', `translate(${xOffset - vis.MARGIN.left},0)`)
                    .call(yAxisCall.scale(y).tickSizeOuter([0]))
                    .style('opacity', 0)
                    .transition()
                    .delay(100)
                    .duration(2500)
                    .style('opacity', 1)

            } else {
                vis.yAxis
                    .transition()
                    .delay(0)
                    .duration(1000)
                    .attr('transform', `translate(${xOffset - vis.MARGIN.left},0)`)
                    .call(yAxisCall.scale(y).tickSizeOuter([0]))
                    .style('opacity', 1)
            }


            if (vis.draws <= 1) {

                vis.zeroLine
                    .attr('x1', x(new Date("1/1/1975 00:00:00 GMT-0800 (Pacific Standard Time)")))
                    .attr('y1', y(50))
                    .attr('x2', vis.gWIDTH)
                    .attr('y2', y(50))
                    .attr('stroke', 'rgba(0,0,0,.7)')
                    .attr('stroke-width', 1)
                    .attr('opacity', 0)
                    .transition()
                    .delay(800)
                    .duration(1200)
                    .attr('opacity', 1)

            } else {
                vis.zeroLine
                    .transition()
                    .duration(1000)
                    .attr('x1', x(new Date("1/1/1975 00:00:00 GMT-0800 (Pacific Standard Time)")))
                    .attr('y1', y(50))
                    .attr('x2', vis.gWIDTH)
                    .attr('y2', y(50))
                    .attr('opacity', 1)
            }

            vis.whiteBox
                .attr('height', vis.height)
                .attr('x', -vis.MARGIN.left)

            /////////////////////////////////
            /////////////////////////////////
            ////////////////////
            const radius = vis.gWIDTH * .005;

            const dots = vis.dots
                .selectAll('.chart-dot')
                .data(vis.info)

            dots.exit().remove()

            dots
                .transition()
                .duration(pan ? 0 : 1000)
                .attr('r', radius)
                .attr('cy', d => getVal(d.date))
                .attr('cx', d => vis.x(new Date(d.date)))

            dots
                .enter()
                .append('circle')
                .attr('class', 'chart-dot')
                .attr('id', (d, i) => 'dot-' + i)
                // .attr('fill', "#005F9E")
                .attr('fill', "transparent")
                .attr('r', 0)
                .attr('cy', d => getVal(d.date))
                .attr('cx', d => vis.x(new Date(d.date)))
                .transition()
                .duration(1000)
                .delay((d, i) => i * 75 + 1200)
                .attr('r', radius)


            function getVal(date) {
                const el = data.find(d => d.date.toDateString() === new Date(date).toDateString())
                return y(el.val)
            }

            ////////////////////
            ///////////////
            ////////////
            const lines = vis.lines
                .selectAll('.chart-line')
                .data(vis.info)

            lines.exit().remove()

            lines
                .transition()
                .duration(pan ? 0 : 1000)
                .attr('x1', d => vis.x(new Date(d.date)))
                .attr('y1', d => getVal(d.date))
                .attr('x2', d => vis.x(new Date(d.date)))
                .attr('y2', d => d.pos === 'dd' ? getVal(d.date) + vis.gHEIGHT * .25 : d.pos === 'u' ? getVal(d.date) - vis.gHEIGHT * .15 : d.pos === 'd' ? getVal(d.date) + vis.gHEIGHT * .15 : getVal(d.date))


            lines
                .enter()
                .append('line')
                .attr('class', 'chart-line')
                .attr('id', (d, i) => 'line-' + i)
                .attr('stroke', "grey")
                .attr('stroke-width', '1px')
                .attr('x1', d => vis.x(new Date(d.date)))
                .attr('y1', d => getVal(d.date))
                .attr('x2', d => vis.x(new Date(d.date)))
                .attr('y2', d => getVal(d.date))
                .transition()
                .duration(1000)
                .delay((d, i) => i * 75 + 1250)
                .attr('y2', d => d.pos === 'dd' ? getVal(d.date) + vis.gHEIGHT * .25 : d.pos === 'u' ? getVal(d.date) - vis.gHEIGHT * .15 : d.pos === 'd' ? getVal(d.date) + vis.gHEIGHT * .15 : getVal(d.date))

            ////////////////////
            ///////////////
            ////////////
            const texts = vis.texts
                .selectAll('.chart-text')
                .data(vis.info)

            texts.exit().remove()

            texts
                .transition()
                .duration(pan ? 0 : 1000)
                .attr('x', d => vis.x(new Date(d.date)))
                .attr('y', d => d.pos === 'dd' ? getVal(d.date) + vis.gHEIGHT * .285 : d.pos === 'u' ? getVal(d.date) - vis.gHEIGHT * .16 : d.pos === 'd' ? getVal(d.date) + vis.gHEIGHT * .185 : getVal(d.date))
                .attr('opacity', 1)

            texts
                .enter()
                .append('text')
                .attr('class', 'chart-text p-16 normal')
                .attr('text-anchor', 'middle')
                .attr('id', (d, i) => 'text-' + i)
                .text(d => d.name)
                .attr('fill', 'black')
                .attr('x', d => vis.x(new Date(d.date)))
                .attr('y', d => d.pos === 'dd' ? getVal(d.date) + vis.gHEIGHT * .285 : d.pos === 'u' ? getVal(d.date) - vis.gHEIGHT * .16 : d.pos === 'd' ? getVal(d.date) + vis.gHEIGHT * .185 : getVal(d.date))
                .attr('opacity', 0)
                .transition()
                .duration(1000)
                .delay((d, i) => i * 75 + 1500)
                .attr('opacity', 1)

        } // end redraw
    } //end class

    //*************************************************************************************************//
    //*************************************************************************************************//


    const chart = new drawChart();

    window.addEventListener("resize", () => redraw());

    function redraw() {
        chart.wrangle(lowDate, highDate);
    }

    // TOGGLE BUTTONS
    function toggleLine() {
        document.querySelector('#toggle-slider').style.left = '0%';
        filled = false;

        document.getElementById('line').style.fill = 'rgba(0, 41, 75, 1)';
        document.getElementById('mountain').style.fill = 'rgba(0, 41, 75, 0.3)';
        document.getElementById('mountain-2').style.fill = 'rgba(0, 95, 158, 0.3)';

        redraw();
    }

    function toggleFill() {
        document.querySelector('#toggle-slider').style.left = '50%';

        document.getElementById('line').style.fill = 'rgba(0, 41, 75, .3)';
        document.getElementById('mountain').style.fill = 'rgba(0, 41, 75, .6)';
        document.getElementById('mountain-2').style.fill = 'rgba(0, 95, 158, .6)';

        filled = true;
        redraw();
    }

    function zoomIn() {
        if (!zoomed) {
            zoomed = true;
            chart.wrangle(oldLowDate, oldHighDate);
            document.querySelector('#chart').style.cursor = `url('./engine/imgs/scroll.svg') 5 5 , ew-resize`;
        }
    }

    function zoomOut() {
        if (zoomed) {
            zoomed = false;

            oldLowDate = lowDate;
            oldHighDate = highDate;

            chart.wrangle(); // EXTENT OF THE DATA ON THE X-AXIS (with default args)
            document.querySelector('#chart').style.cursor = `url('./engine/imgs/cursor.svg') 5 5, crosshair`
        }
    }


    //*************************************************************************************************//
   
    //*************************************************************************************************//

</script>

</html>